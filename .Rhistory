weight = c(135, 156, 139, 144, 152))
people[2, 3] # numer wiersza i numer kolumny
people[2, "height"]
people[,"height"] # wszystkie wiersze z kolumny height
# Przypisywanie zestawu nazw wierszy do wektora.
# Używane są tu wartości z kolumny name.
rownames(people) <- people$name
# Pobieranie wiersza z imieniem "Ada" (i wszystkich kolumn).
people["Ada", ] # Zwróć uwagę na oznaczający wszystkie kolumny przecinek.
# Pobieranie drugiej kolumny jako ramki danych (filtrowanie).
people["height"] # Bez przecinka - zwracana jest ramka danych.
people <- data.frame(
name = c("Ada", "Bartek", "Cyryl", "Daria", "Ela"),
height = c(64, 74, 69, 69, 71),
weight = c(135, 156, 139, 144, 152))
people[2, 3] # numer wiersza i numer kolumny
people[2, "height"]
people[,"height"] # wszystkie wiersze z kolumny height
# Przypisywanie zestawu nazw wierszy do wektora.
# Używane są tu wartości z kolumny name.
rownames(people) <- people$name
# Pobieranie wiersza z imieniem "Ada" (i wszystkich kolumn).
people["Ada", ] # Zwróć uwagę na oznaczający wszystkie kolumny przecinek.
# Pobieranie drugiej kolumny jako ramki danych (filtrowanie).
people["height"] # Bez przecinka - zwracana jest ramka danych.
# Pobieranie kolumn height i weight.
people[, c("height", "weight")] # Zwróć uwagę na przecinek oznaczający wszystkie wiersze.
people <- data.frame(
name = c("Ada", "Bartek", "Cyryl", "Daria", "Ela"),
height = c(64, 74, 69, 69, 71),
weight = c(135, 156, 139, 144, 152))
people[2, 3] # numer wiersza i numer kolumny
people[2, "height"]
people[,"height"] # wszystkie wiersze z kolumny height
# Przypisywanie zestawu nazw wierszy do wektora.
# Używane są tu wartości z kolumny name.
rownames(people) <- people$name
# Pobieranie wiersza z imieniem "Ada" (i wszystkich kolumn).
people["Ada", ] # Zwróć uwagę na oznaczający wszystkie kolumny przecinek.
# Pobieranie drugiej kolumny jako ramki danych (filtrowanie).
people["height"] # Bez przecinka - zwracana jest ramka danych.
# Pobieranie kolumn height i weight.
people[, c("height", "weight")] # Zwróć uwagę na przecinek oznaczający wszystkie wiersze.
# Pobieranie wierszy od drugiego do czwartego.
people[2:4, ] # Zwróć uwagę na przecinek oznaczający wszystkie kolumny.
people <- data.frame(
name = c("Ada", "Bartek", "Cyryl", "Daria", "Ela"),
height = c(64, 74, 69, 69, 71),
weight = c(135, 156, 139, 144, 152))
people[2, 3] # numer wiersza i numer kolumny
people[2, "height"]
people[,"height"] # wszystkie wiersze z kolumny height
# Przypisywanie zestawu nazw wierszy do wektora.
# Używane są tu wartości z kolumny name.
rownames(people) <- people$name
# Pobieranie wiersza z imieniem "Ada" (i wszystkich kolumn).
people["Ada", ] # Zwróć uwagę na oznaczający wszystkie kolumny przecinek.
# Pobieranie drugiej kolumny jako ramki danych (filtrowanie).
people["height"] # Bez przecinka - zwracana jest ramka danych.
# Pobieranie kolumn height i weight.
people[, c("height", "weight")] # Zwróć uwagę na przecinek oznaczający wszystkie wiersze.
# Pobieranie wierszy od drugiego do czwartego.
people[2:4, ] # Zwróć uwagę na przecinek oznaczający wszystkie kolumny.
# Pobieranie wierszy (z wszystkimi kolumnami), w których people$height ma wartość ponad 70.
people[people$height > 70, ] # Zwraca wiersze, w których height ma wartość ponad 70.
people <- data.frame(
name = c("Ada", "Bartek", "Cyryl", "Daria", "Ela"),
height = c(64, 74, 69, 69, 71),
weight = c(135, 156, 139, 144, 152))
people[2, 3] # numer wiersza i numer kolumny
people[2, "height"]
people[,"height"] # wszystkie wiersze z kolumny height
# Przypisywanie zestawu nazw wierszy do wektora.
# Używane są tu wartości z kolumny name.
rownames(people) <- people$name
# Pobieranie wiersza z imieniem "Ada" (i wszystkich kolumn).
people["Ada", ] # Zwróć uwagę na oznaczający wszystkie kolumny przecinek.
# Pobieranie drugiej kolumny jako ramki danych (filtrowanie).
people["height"] # Bez przecinka - zwracana jest ramka danych.
# Pobieranie kolumn height i weight.
people[, c("height", "weight")] # Zwróć uwagę na przecinek oznaczający wszystkie wiersze.
# Pobieranie wierszy od drugiego do czwartego.
people[2:4, ] # Zwróć uwagę na przecinek oznaczający wszystkie kolumny.
# Pobieranie wierszy (z wszystkimi kolumnami), w których people$height ma wartość ponad 70.
people[people$height > 70, ] # Zwraca wiersze, w których height ma wartość ponad 70.
# Funkcja sprawdza czy obiekt jest ramką danych
is.data.frame(people)
# Funkcja zmienająca obiekt na ramkę danych
as.data.frame(people)
knitr::opts_chunk$set(echo = TRUE)
# Wczytywanie danych z pliku my_file.csv do ramki danych my_df.
my_df <- read.csv("R_plik_CSV.csv", stringsAsFactors = FALSE)
# Wczytywanie danych z pliku my_file.csv do ramki danych my_df.
my_df <- read.csv("R_plik_CSV.csv", stringsAsFactors = FALSE)
people <- data.frame(
name = c("Ada", "Bartek", "Cyryl", "Daria", "Ela"),
height = c(64, 74, 69, 69, 71),
weight = c(135, 156, 139, 144, 152))
people[2, 3] # numer wiersza i numer kolumny
people[2, "height"]
people[,"height"] # wszystkie wiersze z kolumny height
# Przypisywanie zestawu nazw wierszy do wektora.
# Używane są tu wartości z kolumny name.
rownames(people) <- people$name
# Pobieranie wiersza z imieniem "Ada" (i wszystkich kolumn).
people["Ada", ] # Zwróć uwagę na oznaczający wszystkie kolumny przecinek.
# Pobieranie drugiej kolumny jako ramki danych (filtrowanie).
people["height"] # Bez przecinka - zwracana jest ramka danych.
# Pobieranie kolumn height i weight.
people[, c("height", "weight")] # Zwróć uwagę na przecinek oznaczający wszystkie wiersze.
# Pobieranie wierszy od drugiego do czwartego.
people[2:4, ] # Zwróć uwagę na przecinek oznaczający wszystkie kolumny.
# Pobieranie wierszy (z wszystkimi kolumnami), w których people$height ma wartość ponad 70.
people[people$height > 70, ] # Zwraca wiersze, w których height ma wartość ponad 70.
# Funkcja sprawdza czy obiekt jest ramką danych
is.data.frame(people)
# Funkcja zmienająca obiekt na ramkę danych
as.data.frame(people)
# Zapisywanie danych z ramki my_df w pliku my_new_file.csv.
# Argument row.names informuje, czy nazwy wierszy
# powinny zostać zapisane w pliku (zwykle nie).
write.csv(people, "my_new_file.csv", row.names = FALSE)
# Pobieranie ścieżki bezwzględnej prowadzącej do bieżącego katalogu roboczego.
getwd()
setwd("D:/OneDrive/Studia podyplomowe/Data_Scientist_Kraków/Uczenie Maszynowe - Praca zaliczeniowa/R_Project_Loans_Paid_Predictions/Projekt_Zaliczeniowy_Loans_Predictions")
dataset <- read_excel("LoanStats_DataSet.xlsx")
library(readxl)
dataset <- read_excel("LoanStats_DataSet.xlsx")
colnames(dataset)
.libPaths()
dataset[, c("loan_status", "loan_amnt")]
dataset[, c("loan_status", "loan_amnt", "purpose", "term")]
dataset[,
c("loan_status" # Status spłacania pożyczki - zmienna niezależna
,"addr_state" # Stan pożyczkobiorcy
,"annual_inc" # Roczne dochody
,"application_type" # Liczba pożyczkobiorców
,"delinq_2yrs" # Liczba 30 dniowych opóźnień w spłacie kredytu
,"emp_length" # Długość zatrudnienia w latach
,"emp_title" # Nazwa zawodu
,"funded_amnt" # Kwota udzielonej pożyczki
,"home_ownership" # Stan własnościowy mieszkania pożyczkobiorcy
,"int_rate" # Oprocentowanie pożyczki
,"issue_d" # Data udzielenia pożyczki
,"loan_amnt" # Kwota pożyczki, ewentualnie zmniejszona p
,"purpose" # Cel pożyczki
, "term" # Liczba lat do spłacenia
)]
knitr::opts_chunk$set(echo = TRUE)
install.packages("dbplyr")
library(dbplyr)
install.packages("dbplyr")
library("dplyr")
installed.packages("dbplyr")
library("dplyr")
install.packages("ODBC")
detach("package:dbplyr", unload = TRUE)
library(odbc)
library(dbplyr)
installed.packages("ODBC")
search()
library("dbplyr")
conn <- RSQLServer::src_sqlserver("RAFALWILK\RAFALWILKSQL", database = "Movies")
conn <- RSQLServer::src_sqlserver("RAFALWILK\\RAFALWILKSQL", database = "Movies")
library(DBI)
con <- dbConnect(odbc::odbc(), .connection_string = "Driver={ODBC Driver 17 for SQL Server};", timeout = 10)
library(DBI)
knitr::opts_chunk$set(echo = TRUE)
library("dbplyr")
install.packages("dbplyr")
installed.packages("dbplyr") # Sprawdzanie czy danych pakiet został zainstalowany
library("dbplyr")
# Sprawdzanie co zostało zainstalowane
search()
install.packages("dbplyr")
install.packages("pscl")
library("pscl")
library("pscl")
# install.packages("pscl")
library("pscl")
view("pscl")
library("pscl")
iew("pscl")
view("pscl")
# install.packages("pscl")
library("pscl")
View("pscl")
View(presidentialElections)
View("presidentialElections")
knitr::opts_chunk$set(echo = TRUE)
shirt_sizes <- c("small", "medium", "small", "large", "medium", "large")
shirt_sizes_factor <- as.factor(shirt_sizes)
print(shirt_sizes_factor)
length(shirt_sizes_factor) # 6
is.factor(shirt_sizes_factor)
knitr::opts_chunk$set(echo = TRUE)
# install.packages("pscl")
library("pscl")
View(presidentialElections)
# Pobieranie kolumn year i demVotes (procent głosów oddanych na Demokratów)
# z ramki danych presidentialElections.
votes <- select(presidentialElections, year, demVote)
library("dbplyr")
# Pobieranie kolumn year i demVotes (procent głosów oddanych na Demokratów)
# z ramki danych presidentialElections.
votes <- select(presidentialElections, year, demVote)
library("dbplyr")
search()
# Pobieranie kolumn year i demVotes (procent głosów oddanych na Demokratów)
# z ramki danych presidentialElections.
votes <- select(presidentialElections, year, demVote)
# Pobieranie kolumn year i demVotes (procent głosów oddanych na Demokratów)
# z ramki danych presidentialElections.
votes <- select(presidentialElections, year, demVote)
votes <- presidentialElections[, c ("year", "demVote")]
library("dplyr")
install.packages("dplyr")
install.packages("dplyr")
knitr::opts_chunk$set(echo = TRUE)
installed.packages("dplyr") # Sprawdzanie czy danych pakiet został
library("dplyr")
search()
votes <- select(presidentialElections, year, demVote)
# install.packages("pscl")
library("pscl")
View(presidentialElections)
votes <- select(presidentialElections, year, demVote)
print(votes)
select(presidentialElections, state:year)
select(presidentialElections, -south)
# Pobieranie wszystkich wierszy dotyczących wyborów z 2008 r.
votes_2008 <- filter(presidentialElections, year == 2008)
# Pobieranie wszystkich wierszy dotyczących wyborów z 2008 r.
votes_2008 <- filter(presidentialElections, year == 2008)
# Pobieranie wszystkich wierszy dotyczących wyborów z 2008 r.
votes_2008 <- filter(presidentialElections, year == 2008)
# Pobieranie wszystkich wierszy dotyczących wyborów z 2008 r.
votes_2008 <- filter(presidentialElections, year == 2008)
votes_2008
votes_colorado_2008 <- filter(
presidentialElections,
year == 2008,
state == "Colorado")
votes_colorado_2008 <- filter(
presidentialElections,
year == 2008,
state == "Colorado")
votes_colorado_2008
# Sortowanie wierszy malejąco według kolumny year, a następnie
# w ramach każdego roku według kolumny demVote.
presidentialElections <- arrange(presidentialElections, -year, demVote)
presidentialElections
# Obliczanie statystyk dla ramki danych presidentialElections.
average_votes <- summarize(
presidentialElections,
mean_dem_vote = mean(demVote),
mean_other_parties = mean(other_parties_vote))
average_votes
average_votes <- summarize(
presidentialElections,
mean_dem_vote = mean(demVote),
mean_other_parties = mean(other_parties_vote))
average_votes <- summarize(
presidentialElections,
mean_dem_vote = mean(demVote),
mean_other_parties = mean(other_parties_vote)
)
View(presidentialElections)
# Dodawanie kolumny other_parties_vote z procentem głosów
# oddanych na inne partie.
# Dodawanie kolumny abs_vote_difference z wartością bezwzględną
# określającą różnicę między wartościami procentowymi.
# Warto zauważyć, że tych kolumn można użyć już w tworzącej je instrukcji.
presidentialElections <- mutate(
presidentialElections,
other_parties_vote = 100 - demVote, # Głosy na inne partie
abs_vote_difference = abs(demVote - other_parties_vote)
)
# umożliwia zmianę kolumn - rename()
View(presidentialElections)
# Obliczanie statystyk dla ramki danych presidentialElections.
average_votes <- summarize(
presidentialElections,
mean_dem_vote = mean(demVote),
mean_other_parties = mean(other_parties_vote)
)
average_votes
knitr::opts_chunk$set(echo = TRUE)
# Używanie sekwencji kroków do znalezienia stanu z największą
# wartością kolumny demVote dla 2008 r.
# 1. Filtrowanie danych w celu uzyskania tylko obserwacji z 2008 r.
votes_2008 <- filter(presidentialElections, year == 2008)
# 2. Filtrowanie danych w celu otrzymania stanu o najwyższej wartości demVote.
most_dem_votes <- filter(votes_2008, demVote == max(demVote))
# 3. Pobieranie nazwy tego stanu.
most_dem_state <- select(most_dem_votes, state)
library("dplyr")
library("pscl")
votes_2008 <- filter(presidentialElections, year == 2008)
# Używanie sekwencji kroków do znalezienia stanu z największą
# wartością kolumny demVote dla 2008 r.
# 1. Filtrowanie danych w celu uzyskania tylko obserwacji z 2008 r.
votes_2008 <- filter(presidentialElections, year == 2008)
# 2. Filtrowanie danych w celu otrzymania stanu o najwyższej wartości demVote.
most_dem_votes <- filter(votes_2008, demVote == max(demVote))
# 3. Pobieranie nazwy tego stanu.
most_dem_state <- select(most_dem_votes, state)
most_dem_state
# Zadawanie tego samego pytania o dane z użyciem operatora potoku.
most_dem_state <- presidentialElections %>% # Pierwotna ramka danych.
filter(year == 2008) %>% # 1. Filtrowanie, aby uzyskać głosy z 2008 r.
filter(demVote == max(demVote)) %>% # 2. Filtrowanie, aby uzyskać stan o największej wartości demVote.
select(state) # 3. Pobieranie nazwy stanu
# Zadawanie tego samego pytania o dane z użyciem operatora potoku.
most_dem_state <- presidentialElections %>% # Pierwotna ramka danych.
filter(year == 2008) %>% # 1. Filtrowanie, aby uzyskać głosy z 2008 r.
filter(demVote == max(demVote)) %>% # 2. Filtrowanie, aby uzyskać stan o największej wartości demVote.
select(state) # 3. Pobieranie nazwy stanu
# Zadawanie tego samego pytania o dane z użyciem operatora potoku.
most_dem_state <- presidentialElections %>% # Pierwotna ramka danych.
filter(year == 2008) %>% # 1. Filtrowanie, aby uzyskać głosy z 2008 r.
filter(demVote == max(demVote)) %>% # 2. Filtrowanie, aby uzyskać stan o największej wartości demVote.
select(state) # 3. Pobieranie nazwy stanu
state
# Zadawanie tego samego pytania o dane z użyciem operatora potoku.
most_dem_state <- presidentialElections %>% # Pierwotna ramka danych.
filter(year == 2008) %>% # 1. Filtrowanie, aby uzyskać głosy z 2008 r.
filter(demVote == max(demVote)) %>% # 2. Filtrowanie, aby uzyskać stan o największej wartości demVote.
select(state) # 3. Pobieranie nazwy stanu
# Zadawanie tego samego pytania o dane z użyciem operatora potoku.
most_dem_state <- presidentialElections %>% # Pierwotna ramka danych.
filter(year == 2008) %>% # 1. Filtrowanie, aby uzyskać głosy z 2008 r.
filter(demVote == max(demVote)) %>% # 2. Filtrowanie, aby uzyskać stan o największej wartości demVote.
select(state) # 3. Pobieranie nazwy stanu
most_dem_state
# Tworznie grup na podstawie jakieś zmiennej w tym przypadku: STATE
grouped <- group_by(presidentialElections, state)
grouped
VIEW(grouped)
View(grouped)
# Tworznie grup na podstawie jakieś zmiennej w tym przypadku: STATE
grouped <- group_by(presidentialElections, state)
print(grouped)
# Tworznie grup na podstawie jakieś zmiennej w tym przypadku: STATE
grouped <- group_by(presidentialElections, state)
print(grouped)
# Obliczanie statystyk podsumowujących dla stanów — średnie wartości procentowe z wielu lat.
state_voting_summary <- presidentialElections %>%
group_by(state) %>%
summarize(
mean_dem_vote = mean(demVote),
mean_other_parties = mean(other_parties_vote)
)
# Obliczanie statystyk podsumowujących dla stanów — średnie wartości procentowe z wielu lat.
state_voting_summary <- presidentialElections %>%
group_by(state) %>%
summarize(
mean_dem_vote = mean(demVote),
mean_other_parties = mean(other_parties_vote))
state_voting_summary
# Obliczanie statystyk podsumowujących dla stanów — średnie wartości procentowe z wielu lat.
state_voting_summary <- presidentialElections %>%
group_by(state) %>%
summarize(
mean_dem_vote = mean(demVote),
mean_other_parties = mean(other_parties_vote))
state_voting_summary <- as.data.frame(state_voting_summary)
state_voting_summary
knitr::opts_chunk$set(echo = TRUE)
# Obliczanie statystyk podsumowujących dla stanów — średnie wartości procentowe z wielu lat.
state_voting_summary <- presidentialElections %>%
group_by(state) %>%
summarize(
mean_dem_vote = mean(demVote),
mean_other_parties = mean(other_parties_vote))
# Przekształcanie ramki tibble na zwykłą ramkę danych
state_voting_summary <- as.data.frame(state_voting_summary)
state_voting_summary
print(donations)
# Wczytywanie pakietu nycflights13 w celu uzyskania dostępu do ramki danych flights.
install.packages("nycflights13") # Raz w każdym komputerze.
library("nycflights13") # W każdym skrypcie.
# Zapoznawanie się ze zbiorem danych flights.
?flights # Wyświetlanie dostępnej dokumentacji.
dim(flights) # Sprawdzanie liczby wierszy i kolumn.
colnames(flights) # Sprawdzanie nazw kolumn.
View(flights) # Wyświetlanie ramki danych w przeglądarce w środowisku RStudio.
?flights # Wyświetlanie dostępnej dokumentacji.
dim(flights) # Sprawdzanie liczby wierszy i kolumn.
colnames(flights) # Sprawdzanie nazw kolumn.
colnames(flights) # Sprawdzanie nazw kolumn.
# Znajdowanie linii lotniczych (carrier) z największą liczbą
# opóźnionych lotów.
has_most_delays <- flights %>% # Zaczynamy od ramki danych fligths.
group_by(carrier) %>% # Grupowanie według linii lotniczych (carrier).
filter(dep_delay > 0) %>% # Wyszukiwanie samych opóźnień.
summarize(num_delay = n()) %>% # Zliczanie obserwacji.
filter(num_delay == max(num_delay)) %>% # Znajdowanie grupy z największą liczbą obserwacji.
select(carrier) # Pobieranie nazwy linii lotniczych.
has_most_delays
library("dplyr")
has_most_delays <- flights %>% # Zaczynamy od ramki danych fligths.
group_by(carrier) %>% # Grupowanie według linii lotniczych (carrier).
filter(dep_delay > 0) %>% # Wyszukiwanie samych opóźnień.
summarize(num_delay = n()) %>% # Zliczanie obserwacji.
filter(num_delay == max(num_delay)) %>% # Znajdowanie grupy z największą liczbą obserwacji.
select(carrier) # Pobieranie nazwy linii lotniczych.
has_most_delays
# Rozpoznawanie co ten skrót z poprzedniej analizy oznacza
most_delayed_name <- has_most_delays %>% # Rozpoczynanie od uzyskanej wcześniej odpowiedzi.
left_join(airlines, by = "carrier") %>% # Złączanie na podstawie identyfikatora linii.
select(name) # Pobieranie nazwy linii lotniczych.
print(most_delayed_name$name) # Dostęp do wartości z ramki tibble.
# [1] "United Air Lines Inc."
print(airlines)
# Obliczanie średniego opóźnienia przylotów (arr_delay)
# dla każdego docelowego lotniska (dest).
most_early <- flights %>%
group_by(dest) %>% # Grupowanie na podstawie docelowego lotniska.
summarize(delay = mean(arr_delay)) # Obliczanie średniego opóźnienia.
# Obliczanie średniego opóźnienia przylotów (arr_delay)
# dla każdego docelowego lotniska (dest).
most_early <- flights %>%
group_by(dest) %>% # Grupowanie na podstawie docelowego lotniska.
summarize(delay = mean(arr_delay)) # Obliczanie średniego opóźnienia.
most_early
# Obliczanie średniego opóźnienia dla docelowych lotnisk z pominięciem wyników NA.
most_early <- flights %>%
group_by(dest) %>% # Grupowanie według docelowych lotnisk.
summarize(delay = mean(arr_delay, na.rm = TRUE)) # Obliczanie           średniego opóźnienia.
most_early
# Identyfikowanie lokalizacji, gdzie loty średnio docierają najwcześniej względem planu.
most_early <- flights %>%
group_by(dest) %>% # Grupowanie według lokalizacji docelowej.
summarize(delay = mean(arr_delay, na.rm = TRUE)) %>% # Obliczanie       średniego opóźnienia.
filter(delay == min(delay, na.rm = TRUE)) %>% # Filtrowanie pod kątem   najmniejszego opóźnienia.
select(dest, delay) %>% # Pobieranie lokalizacji docelowej  (i           opóźnienia w celu zapisania go).
left_join(airports, by = c("dest" = "faa")) %>% # Złączanie z ramką     danych airports.
select(dest, name, delay) # Pobieranie szukanych zmiennych        wyjściowych.
print(most_early)
# Ramka tibble o wymiarach 1 na 3.
# dest name delay
# <chr> <chr> <dbl>
# 1 LEX Blue Grass -22
# Identyfikowanie lokalizacji, gdzie loty średnio docierają najwcześniej względem planu.
most_early <- flights %>%
group_by(dest) %>% # Grupowanie według lokalizacji docelowej.
summarize(delay = mean(arr_delay, na.rm = TRUE)) %>% # Obliczanie       średniego opóźnienia.
filter(delay == min(delay, na.rm = TRUE)) %>% # Filtrowanie pod kątem   najmniejszego opóźnienia.
select(dest, delay) %>% # Pobieranie lokalizacji docelowej  (i           opóźnienia w celu zapisania go).
left_join(airports, by = c("dest" = "faa")) %>% # Złączanie z ramką     danych airports.
select(dest, name, delay) # Pobieranie szukanych zmiennych        wyjściowych.
print(most_early)
# Identyfikowanie lokalizacji, gdzie loty średnio docierają najwcześniej względem planu.
most_early <- flights %>%
group_by(dest) %>% # Grupowanie według lokalizacji docelowej.
summarize(delay = mean(arr_delay, na.rm = TRUE)) %>% # Obliczanie       średniego opóźnienia.
filter(delay == min(delay, na.rm = TRUE)) %>% # Filtrowanie pod kątem   najmniejszego opóźnienia.
select(dest, delay) %>% # Pobieranie lokalizacji docelowej  (i           opóźnienia w celu zapisania go).
left_join(airports, by = c("dest" = "faa")) %>% # Złączanie z ramką     danych airports.
select(dest, name, delay) # Pobieranie szukanych zmiennych        wyjściowych.
print(most_early)
most_early <- flights %>%
group_by(dest) %>% # Grupowanie według lokalizacji docelowej.
summarize(delay = mean(arr_delay, na.rm = TRUE)) %>% # Obliczanie       średniego opóźnienia.
filter(delay == min(delay, na.rm = TRUE)) %>% # Filtrowanie pod kątem   najmniejszego opóźnienia.
select(dest, delay) %>% # Pobieranie lokalizacji docelowej  (i           opóźnienia w celu zapisania go).
left_join(airports, by = c("dest" = "faa")) %>% # Złączanie z ramką     danych airports.
select(dest, name, delay) # Pobieranie szukanych zmiennych        wyjściowych.
print(most_early)
most_early
# Identyfikowanie miesiąca, w którym loty mają zwykle największe opóźnienia.
flights %>%
group_by(month) %>% # Grupowanie na podstawie odpowiedniego atrybutu.
summarize(delay = mean(arr_delay, na.rm = TRUE)) %>% # Podsumowanie na   podstawie opóźnień.
filter(delay == max(delay)) %>% # Filtrowanie pod kątem szukanego       rekordu.
select(month) %>% # Pobieranie kolumny z odpowiedzią na pytanie.
print() # Bezpośrednie wyświetlanie ramki tibble.
# A tibble: 1 x 1.
# month
# <int>
# 1 7
# Obliczanie opóźnień według miesięcy i dodawanie nazw miesięcy na potrzeby wizualnej prezentacji wyników.
# Zauważ, że month.name to zmienna wbudowana w języku R.
delay_by_month <- flights %>%
group_by(month) %>%
summarize(delay = mean(arr_delay, na.rm = TRUE)) %>%
select(delay) %>%
mutate(month = month.name)
delay_by_month
# Tworzenie wykresu za pomocą pakietu ggplot2
ggplot(data = delay_by_month) +
geom_point(mapping = aes(x = delay, y = month)
,color = "blue"
,alpha = .4
,size = 3) +
geom_vline(xintercept = 0, size = .25) +
xlim(c(-20, 20)) +
scale_y_discrete(limits = rev(month.name)) +
labs(title = "Średnie opóźnienie w poszczególnych miesiącach",
y = "", x = "Opóźnienie (w minutach)")
library(ggplot2)
ggplot(data = delay_by_month) +
geom_point(mapping = aes(x = delay, y = month)
,color = "blue"
,alpha = .4
,size = 3) +
geom_vline(xintercept = 0, size = .25) +
xlim(c(-20, 20)) +
scale_y_discrete(limits = rev(month.name)) +
labs(title = "Średnie opóźnienie w poszczególnych miesiącach",
y = "", x = "Opóźnienie (w minutach)")
